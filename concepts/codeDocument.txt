
1、校验IP地址是否在CIDR范围内
我们一般用CIDR来表示一段ip地址。CIDR是这样一个字符串：先是一个ipv4的地址的字符串表示，加一个”/“分隔符，再加一个13（含）到27（含）之间的整数。比如“192.128.1.134/25”，表示从192.128.1.128（含）到192.128.1.255（含）的128个ip地址。
”/“前的字段“192.128.1.134”表示该范围内的一个ip地址（不一定是第一个ip地址）。
“/“之后的整数“25”表示该地址段里的所有ip地址的二进制形式，前25个bit都是相同的，也就是都是”1100 0000   1000 0000  0000 0001 1” 。
输入：给定一个ip地址和一个CIDR
输出：如果ip在CIDR内，输出true。不然，输出false
Java 函数可以是这样的：
boolean checkIPinCIDR(String ip, String cidr)
也可用其他任意语言实现
 
=================================

思路：CIDR可用来表示一个ip地址序列 从某一ip到另一ip
给定CIDR字符串 包含一个ip地址和一个 13-27的整数 （暂用x表示） 
该段ip地址共享同一段前缀 前缀位数为／分隔符后的数字x
要想校验某ip地址是否在CIDR范围内 只要看该ip地址的前x位是否与CIDR字符串的前x位是否相等
实现时注意将字符串用正则表达式split成int型数组 大小为4 
再将从十进制转化为二进制字符串 ip地址的前x位与CIDR的前x位 字符串判断是否相等
这里用位操作进行比较也可以 但要注意位数 保存成long型
 



2、有存活时间的缓存
请补充如下的构造函数和get()函数，设计实现一个支持失效时间的缓存。缓存的数据是一个List。如果举例上一次刷新数据的时间不超过timeoutMillis毫秒，那么直接返回缓存的数据，否则，调用populateCache()去刷新所有的缓存数据。populateCache由具体的使用者自己实现，请参考实现类。
 
public abstract class CachedObjs<T> {
//timeoutMillis, unit is millisecond
public CachedObjs(long timeoutMillis) {
//TODO: add your code here
}
 
//if forceReload is true, then force refreshing all data
public List<T> get(boolean forceReload) {
//TODO: add your code here
}
 
//clear all cached data
public void clear() {
//TODO: add your code here
}
protected abstract void populateCache(List<T> objects);
}
 
 
实现类（供读者参考，方便读者理解）：
public final CachedObjs<String> test = new CachedObjs<String>(1000*60*60) {
@Override
protected void populateCache(List<String> objects) {
objects.clear();
 
Random ra = new Random();
       for (int i=0;i<1000;i++){
       
objects.add(Integer.toBinaryString(ra.nextInt()));
       }
}
};


＝＝＝＝＝＝
思路：按照给定模板填入简单逻辑 
具体实现参考代码


 
 
3、求最大并发桌面池
Horizon是VMware的桌面虚拟化产品，多个用户可以同时连接到一个桌面池上使用远程桌面。同一时刻，一个桌面池上已经连接的用户数，称为此桌面池的并发连接数。同一个用户，对于同一个桌面池，同一时刻只会有一个连接。
如果同一个桌面池，一个连接的断开时间恰好是另一个连接的建立时间，不认为这两个连接是并发的。
输入是N*4的二维数组,表示一共有N个连接, 每个连接由4个Long Integer整数来表示，分别是 “User ID”, “Pool ID”, “Connection time”, “Disconnection time”. “Connection time”总是小于“Disconnection time“。
要求是分析这N个连接的数据，找出并发连接数最大的那个桌面池，输出此桌面池的ID。
如果有多个桌面池并发连接数最大，输出任意其中一个桌面池的id
举例：
输入：
10000 20000 1411325674537 1411325726830
10001 20001 1411325632683 1411325731213
10002 20000 1411325508697 1411325726810
输出：
20000
 
 
 
解释：
”20000“这个桌面池在” 1411325674537“到” 1411325726810“这段时间存在两个并发连接。
如果你用Java写，那么你的函数可以是：
public Long getMaxConcurrentPool(Long[][] connections)
 
答案：  求有最大并发连接数的桌面池


=====================
思路：
两个hash map
	一个维护pool id和其最大并发连接数；一个维护pool id和其所有并发连接信息的list
两个循环
	外循环遍历所有数据 将数据中的connection信息加入到所有并发连接中形成连续区间；内循环遍历并发连接list 根据当前数据connection信息更新已有的并发连接进行分段处理

具体实现：

1. 建立两个hash map：
一个存储pool id和 其最大并发连接数 <Pool id, MaxCount>
一个存储pool id和 该池中所有的时间段及时间段所对应的并发连接数<Pool id, connections[start, end, count] >

2. 外循环：遍历所有数据(outer loop)
初始化当前数据：
－如果该数据中的pool在之前的遍历中并没有任何连接 新建一个储存所有连接的list 加入当前时间段  并更新hashmap中该pool的信息
－如果该数据中的pool在之前的遍历中曾经出现过
记录min为原所有并发连接最早的起始时间 
记录max为原所有并发连接最晚的结束时间
分别记下min，max在list中的位置 因为list的增删改都会使其其中的元素位置改变
seg[] seg[0]起始位置 seg[1]终止位置 seg[2]计数
首先要将当前时间段加入已有时间段并形成连续区间 判断条件：
－终止位置等于所有时间段最早起始时间：在list头部加入当前时间段 计数1
－终止位置早于所有时间段最早起始时间：在list头部加入当前时间段结束时间到原最早起始时间的时间段 计数0 在list头部加入当前时间段 计数1 
－起始位置等于所有时间段最晚结束时间：在list尾部加入当前时间段 计数1
－起始位置晚于所有时间段最晚结束时间：在list尾部加入原最晚结束时间到当前时间段开始时间的时间段 计数0 在list尾部加入当前时间段 计数1 
－起始位置早于所有时间段最早起始时间 且 终止位置晚于所有时间段最早开始时间：在list头部加入当前时间段开始时间到原最早起始时间的时间段 计数1 
－起始位置早于所有时间段最晚结束时间 且 终止位置早于所有时间段最晚结束时间：在list尾部加入原最晚结束时间到当前时间段结束时间的时间段 计数1
－处理完上述情况后 对于起始位置晚于所有时间段最早结束时间 且 终止位置早于所有时间段最晚结束时间的部分时间段：

内循环：遍历包含所有已经存在的所有时间段的连续区间timeSegment(inner loop)
	－起始位置早于等于当前时间段起始时间 且 终止位置晚于于等于当前时间段结束时间： 当前时间段计数＋1 并判断其与当前pool的最大计数的大小关系并更新 若起始位置终止位置刚好与当前时间段重叠 innerloop结束
	－起始位置晚于当前时间段开始时间 且 终止位置晚于当前时间段结束时间：更新当前时间段结束时间为数据起始位置 并加入从数据起始位置到当前时间段结束时间的小时间段 计数＋1 并判断其与当前pool的最大计数的大小关系并更新 由于时间段更新，将小时间段加入到所有时间段timeSegment中
	－起始位置早于等于当前时间段起始时间 且 终止位置早于当前时间段结束时间：更新当前时间段结束时间为数据终止位置 计数＋1 并判断其与当前pool的最大计数的大小关系并更新 并加入从数据终止位置到当前时间段结束时间的小时间段 由于时间段更新，将小时间段加入到所有时间段timeSegment中
	－起始位置晚于当前时间段开始时间 且 终止位置早于当前时间段结束时间：更新当前时间短结束时间结束时间为数据起始位置 并加入从数据起始位置到结束位置的小时间段 计数＋当前时间段的计数 并判断其与当前pool的最大计数的大小关系并更新 加入从数据终止位置到当前时间段结束时间的小时间段 由于时间段更新，将小时间段加入到所有时间段timeSegment中 innerloop结束

遍历存有<pool id, maxCount>的hash map,找到最大值并输出

其他解法：
还有一种解法相对简单但耗时间耗内存 
思路：
建立一个极大的二维数组，数组的大小是pool的数量 每一个一维数组中 下标代表某一特定时间点，数值代表该时间点并发连接数
遍历所有的给定数据 更新所有时间点的并发连接数
遍历数组所有值 找出最大的并发连接数
这个办法缺点在于非常耗内存耗时间 空间复杂度高

当数据量较小 并发时间长 数据所在时间段长时考虑第一种解法 
并发时间短 数据的总时间段短的时候可以考虑第二种解法
